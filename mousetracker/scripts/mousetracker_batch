#!/usr/bin/env python
"""
Bout Analyzer.   Extracts bilateral whisking and eyeblink data from a video snippet.

Usage:
    mousetracker_batch -h | --help
    mousetracker_batch --version
    mousetracker_batch ([-i <input_file> | --input <input_file>] | --print_config) [--config <config_file>]
                 [(-o <output_file> | --output <output_file>)] [(-v | --verbose)] [--clean]

Options:
    -h --help                   Show this screen and exit.
    --version                   Display the version and exit.
    --print_config              Print the default config value and exit.
    -i --input=<input_file>     Specify the file to process.
    -o --output=<output_file>   Specify a location to store the analyzed results.
    --config=<config_file>      Specify a path to a custom config file.  See --print-config for format.
    --clean                     If existing processed videos and analysis data exist, overwrite them with new.
    -v --verbose                Display extra diagnostic information during execution.

"""
import math
import shlex
import subprocess
import sys
from importlib.machinery import SourceFileLoader
from multiprocessing import cpu_count
from os import path
from joblib import Parallel, delayed
import cv2
import numpy as np
from attrs_utils.interop import from_docopt

MAX_CPUS = math.ceil(cpu_count() / 2)
FRAMERATE = 240

ab_path = path.join(path.dirname(path.abspath(__file__)), "analyze_bout")
ab = SourceFileLoader('analyze_bout', ab_path).load_module()

def main(inputargs):
    args = from_docopt(docstring=__doc__, argv=inputargs)
    times = time_slices(args.input)
    files = chunk(args.input)
    # Parallel(n_jobs=2)(delayed(extract_whisk_data)(f, app_config, KEEP_FILES) for f in results.videos)

    #Parallel(n_jobs=MAX_CPUS)(delayed(chunk)(args.input))
    for f in files:
        process(f)

def process(splitfile):
    commandstring = shlex.split(f'-i \"{splitfile}\"')
    result = ab.main(commandstring)
    print(f'{splitfile} completed with return code {result.returncode}')


def chunk(source: str) -> [str]:
    """
    Break a video into sections to maximize CPU use.
    :param source: 
    :return: 
    """
    retval = []
    for start, stop in time_slices(source):
        retval.append(extract_slice(source, start, stop))
    return retval

def extract_slice(source, start, stop):
    name, ext = path.splitext(path.basename(source))
    output_name = f'{name}_{start:2.2f}_{stop:2.2f}{ext}'
    commandstring = shlex.split(f'ffmpeg -i \"{source}\" -ss {start} -t {stop} \"{output_name}\"')
    commandstring = [c.replace(' ', '\ ') for c in commandstring]
    result = subprocess.run(commandstring, stdout=subprocess.PIPE)
    if result.returncode != 0:
        raise IOError('ffmpeg failed to run')
    else:
        return output_name

def time_slices(source)->[()]:
    cap = cv2.VideoCapture(source)
    framecount = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))
    duration_sec = framecount / FRAMERATE
    nchunks = math.ceil(duration_sec / MAX_CPUS)
    chunk_duration = duration_sec / nchunks
    start_times = np.linspace(start=0, stop=duration_sec - chunk_duration, num=nchunks)
    stop_times = np.linspace(start=chunk_duration, stop=duration_sec, num=nchunks)
    cap.release()
    return zip(start_times, stop_times)

if __name__ == "__main__":
    sys.exit(main(sys.argv[1:] if len(sys.argv) > 1 else "-h"))
